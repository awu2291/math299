addpath '~/Documents/MATLAB/1.1-master/miditoolbox/'
savepath

%Read Midi file of Claire de Lune

[demo_collection,filenames] = dir2coll;
clair_de_lune = demo_collection{2};
deux_arabesques = demo_collection{4};

%Transposing deux_arabesques to same key as clair_de_lune (D flat)
deux_arabesques(:,4) = deux_arabesques(:,4) - 3;


%Data Labels are: ONSET(BEATS)  DURATION(BEATS)  MIDI_CHANNEL  MIDI_PITCH  VELOCITY ONSET(SEC)  DURATION(SEC)

training_data = [clair_de_lune; deux_arabesques];


beat_vector = [0.25, 0.5, 1, 1.5, 2, 3, 4];

%want the indices such that we can map each beat in the training data to the closest beat in the beat_vector
[~, index_beats] = min(abs(training_data(:,2) - beat_vector), [], 2);

%stores beats via an array of indices correspeonding to the beat_vector
adj_beats = index_beats;


training_data(:,2); %checking beats

beat_matrix = zeros(length(beat_vector), length(beat_vector));

for k = 1:length(training_data)-1
    i = adj_beats(k);
    j = adj_beats(k+1);
    beat_matrix(i,j) = beat_matrix(i,j) + 1;
end

beat_matrix;



% Find row sums
beat_row_sums = sum(beat_matrix,2);

% Prevent division by zero
beat_row_sums(beat_row_sums == 0) = 1;


% Normalize transition matrix
normalized_beat_matrix = beat_matrix ./ beat_row_sums;


% Check if the rows sum to 1
disp(sum(normalized_beat_matrix, 2)); % Should be = to 1 for nonzero rows

normalized_beat_matrix;
normalized_beat_matrix_summed = cumsum(normalized_beat_matrix,2);



%DATA CLEANING

%Display adjusted midi data
training_data;


%mod = 0 - C, 1 - C#, 2 - D, 3 - D#, 4 - E, 5 - F, 6 - F#, 7 - G, 8-G#,
%9-A, 10-A#, 11-B, 12-B#

%initialize transition matrix
trans_matrix = zeros(12,12);

%constructing transition matrix
for k = 1:length(training_data)-1
    i = mod(training_data(k,4),12) + 1;
    j = mod(training_data(k+1,4),12) + 1;
    trans_matrix(i,j) = trans_matrix(i,j) + 1;
end



%% 

% Find row sums
row_sums = sum(trans_matrix,2);

% Prevent division by zero
row_sums(row_sums == 0) = 1;

% Normalize transition matrix
normalized_trans_matrix = trans_matrix ./ row_sums;

% Check if the rows sum to 1
disp(sum(normalized_trans_matrix, 2)); % Should be = to 1 for nonzero rows


%display normalized pitch transition matrix
normalized_trans_matrix;


        


%%
% PLOT PROPORTION OF TIME TRAINING DATA SPENDS IN EACH PITCH CLASS
pitchprop = pcdist1(training_data);

figure(1)
plotdist(pitchprop) 
for i = 1:12
    text(i, pitchprop(i) + 0.001, sprintf('%.2f', pitchprop(i)),'HorizontalAlignment', 'center', 'VerticalAlignment', 'bottom', 'FontSize', 20);
end

%%

%SOLVING FOR STATIONARY PROBABILITIES OF PITCHES

%Check that transition matrices are irreducible
mc = dtmc(normalized_trans_matrix);
tf = isreducible(mc);

mc2 = dtmc(normalized_beat_matrix);
tf = isreducible(mc2);

%Check that transition matrices are aperiodic by checking for non-zero
%diagonal elements
diag(normalized_trans_matrix);
diag(normalized_beat_matrix_summed);


% pi = [pi_1 pi_2 pi_3 ... pi_12] = [pi_1 pi_2 pi_3 ... pi_12]*P = pi*P (1)
% pi_1 + pi_2 + ... + pi_12 = 1 (2)

A=(eye(size(normalized_trans_matrix))-normalized_trans_matrix)';
A_with_constraint_row = [A; 1 1 1 1 1 1 1 1 1 1 1 1];
b_with_constraint_row = [zeros(12,1); 1];

stationary_pi = (A_with_constraint_row\b_with_constraint_row )';

disp('The stationary distribution of the pitches=')
disp(stationary_pi)

stationary_pi_summed = cumsum(stationary_pi); %take cumulative sum of pitch stationary distribution to use as an initial probability vector




%SOLVING FOR STATINOARY PROBABILITIES OF BEATS
A2=(eye(size(normalized_beat_matrix))-normalized_beat_matrix)';
A2_with_constraint_row = [A2; 1 1 1 1 1 1 1 ];
b2_with_constraint_row = [zeros(7,1); 1];

beats_stationary_pi = (A2_with_constraint_row\b2_with_constraint_row )';

disp('The stationary distribution of the beats=')
disp(beats_stationary_pi)

beats_stationary_pi_summed = cumsum(beats_stationary_pi); %take cumulative sum of beat stationary distribution to use as an initial probability vector




%beat vector
beat_possibilities = [0.25, 0.5, 1, 1.5, 2, 3, 4]; %sixteenth, eigth, quarter, dotted quarter, half, dotted half, whole note


for p = 1:3 %generates 3 compositions

    %Generating starting beat
    beats = 0;
    
    beat_diff = beats_stationary_pi_summed - rand(1);
    beat1 = beat_diff(find(beat_diff >= 0,1));
    pitch_beat = find(beat_diff == beat1,1);
    
    beat_vec = [beat_possibilities(pitch_beat)]; %stores composed beat vector
    
    
    %Find starting pitch using stationary probabilities
    
  
    next_pitch = find(stationary_pi_summed >= rand(1), 1);
    composition = next_pitch;  
    normalized_trans_matrix_summed = cumsum(normalized_trans_matrix,2);
    
    
    while beats < 32
        unifs = rand(2,1);
        %find next pitch

        next_pitch = find(normalized_trans_matrix_summed(next_pitch,:) >= unifs(1), 1);
        composition = [composition next_pitch];
    
        %assign next pitch time value in beat length
        pitch_beat = find(normalized_beat_matrix_summed(pitch_beat,:) >= unifs(2),1);
        next_beat = beat_possibilities(pitch_beat);
        beats = beats + next_beat;
        beat_vec = [beat_vec next_beat];
    end
    
    
    composition;
    beat_vec;
    
    %Need to transpose composition into mid-pitch range so that it is a playable file. The following will transpose pitch 1 (C1) to middle C (C4), which has a pitch number of 60. 
    composition_final = composition + 59;
    
    
    
    % %GENERATE MIDI FILE 
    midi_array = cell(size(composition_final));
    
    tempo_scaling = 0.5;
    %assume a BPM = 120; half second per beat

    nmat = zeros(length(composition_final),7);

    % ONSET(BEATS)  DURATION(BEATS)  MIDI_CHANNEL  MIDI_PITCH  VELOCITY ONSET(SEC)  DURATION(SEC)
    nmat(:,1) = [0, cumsum(beat_vec(1:end-1))]';  %Onset(beats)
    nmat(:,2) = beat_vec; %duration(beats)
    nmat(:,3) = 1; %MIDI Channel 1
    nmat(:,4) = composition_final; %pitches
    nmat(:,5) = 60;  % velocity 
    nmat(:,6) = nmat(:,1)*tempo_scaling;  %Onset(Sec)
    
    %duration(sec)
    for i = 1:length(composition)
        nmat(i,7) = beat_vec(i)*tempo_scaling;  
    end
        
    
    filename = ['/Users/abbeywu/Documents/MATLAB/MIDI_Files/First Order Compositions/composition_first_order_', num2str(p), '.mid'];

    writemidi(nmat, filename);

end

%reads midi files of MATLAB generated compositions
midi_data = readmidi('/Users/abbeywu/Documents/MATLAB/MIDI_Files/First Order Compositions/composition_first_order_1.mid');
midi_data_2 = readmidi('/Users/abbeywu/Documents/MATLAB/MIDI_Files/First Order Compositions/composition_first_order_2.mid');
midi_data_3 = readmidi('/Users/abbeywu/Documents/MATLAB/MIDI_Files/First Order Compositions/composition_first_order_3.mid');


training = [midi_data; midi_data_2; midi_data_3];
pitchprop = pcdist1(training);

%plots proportion of time the computer generated compositions spend in each pitch class

figure(2)
plotdist(pitchprop) 
for i = 1:12
    text(i, pitchprop(i) + 0.001, sprintf('%.2f', pitchprop(i)),'HorizontalAlignment', 'center', 'VerticalAlignment', 'bottom', 'FontSize', 20);
end





